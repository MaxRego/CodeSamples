<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html xmlns:cis="http://zlab.bu.edu/schema/cisml" xmlns:mem="http://noble.gs.washington.edu/meme"><head><meta charset="UTF-8"><meta name="description" content="Motif Cluster Alignment and Search Tool (MCAST) output."><title>MEME Visualizer</title><script type="text/javascript">
        var motifs = new Array();        motifs["CCGGT"] = new Motif("CCGGT", "nucleotide", "     ", "")        motifs["TTAA"] = new Motif("TTAA", "nucleotide", "    ", "")

        var wrap = undefined;//size to display on one line
        var wrap_timer;

        var seqmax = 47;

        var loadedSequences = new Array();
        //draging details
        var moving_seq;
        var moving_annobox;
        var moving_left;
        var moving_width;
        var moving_both;

        //drag needles
        var dnl = null;
        var dnr = null;
        var drag_is_rc = undefined;
        //container
        var cont = null;
        
        function mouseCoords(ev) {
          ev = ev || window.event;
          if(ev.pageX || ev.pageY){ 
	          return {x:ev.pageX, y:ev.pageY}; 
	        } 
	        return { 
	          x:ev.clientX + document.body.scrollLeft - document.body.clientLeft, 
	          y:ev.clientY + document.body.scrollTop  - document.body.clientTop 
	        };
        }

        function setup() {
          rewrap();
          window.onresize = delayed_rewrap;
        }

        function calculate_wrap() {
          var est_wrap = 0;
          var page_width;
          if (window.innerWidth) {
            page_width = window.innerWidth;
          } else if (document.body) {
            page_width = document.body.clientWidth;
          } else {
            page_width = null;
          }
          if (page_width) {
            var ruler_width = document.getElementById("ruler").offsetWidth;
            est_wrap = Math.floor(page_width / ruler_width) * 5;
          }
          if (est_wrap > 20) {
            wrap = est_wrap - 20; 
          } else {
            wrap = 100;
          }
        }

        function rewrap() {
          var previous_wrap = wrap;
          calculate_wrap();
          if (previous_wrap != wrap) {
            for (var seqid in loadedSequences) {
              //exclude inherited properties and undefined properties
              if (!loadedSequences.hasOwnProperty(seqid) || loadedSequences[seqid] === undefined) continue;
            
              var sequence = loadedSequences[seqid];
              var annobox = document.getElementById(seqid + "_annotation");
              var leftPos = parseInt(document.getElementById(seqid + "_dnl").firstChild.firstChild.nodeValue);
              var rightPos = parseInt(document.getElementById(seqid + "_dnr").firstChild.firstChild.nodeValue);
              var is_rc = undefined;
              set_data(leftPos, rightPos - leftPos + 1, is_rc, sequence, annobox);
            }
          }
          if (wrap_timer) {
            clearTimeout(wrap_timer);
          }
          wrap_timer = setTimeout("rewrap()", 5000);
        }

        function delayed_rewrap() {
          if (wrap_timer) {
            clearTimeout(wrap_timer);
          }
          wrap_timer = setTimeout("rewrap()", 1000);
        }

        function showHidden(prefix) {
          document.getElementById(prefix + '_activator').style.display = 'none';
          document.getElementById(prefix + '_deactivator').style.display = 'block';
          document.getElementById(prefix + '_data').style.display = 'block';
        }
        function hideShown(prefix) {
          document.getElementById(prefix + '_activator').style.display = 'block';
          document.getElementById(prefix + '_deactivator').style.display = 'none';
          document.getElementById(prefix + '_data').style.display = 'none';
        }


        function show_more(seqid) {
          if (wrap == undefined) rewrap();
          
          var seq_row = document.getElementById(seqid + "_blocks");
          var info_row = document.getElementById(seqid + "_info");
          var tbl = document.getElementById("tbl_sequences");
          if (info_row) {
            tbl.deleteRow(info_row.rowIndex);
            destroy_seq_handle(seqid, true);
            destroy_seq_handle(seqid, false);
            delete loadedSequences[seqid];
          } else {
            var sequence = new Sequence(seqid);
            var offset = sequence.segs[0].start;
            loadedSequences[seqid] = sequence;
            info_row = tbl.insertRow(seq_row.rowIndex + 1);
            info_row.id = seqid + "_info";
            var cell = info_row.insertCell(0);
            cell.colSpan = 8;
            cell.style.verticalAlign = "top";
            var width = Math.min(sequence.length, wrap); 
            var start = 1;
            var is_neg_strand = false;
            //center on the first hit
            if (sequence.hits.length > 0) {
              var hit = sequence.hits[0];
              is_neg_strand = hit.is_rc;
              start = hit.pos - offset;
            }
            if (start + width >= sequence.length) start = sequence.length - width;
            create_info_section(cell, sequence, seqid, start+offset, width, is_neg_strand);
            var blockCont = document.getElementById(seqid + "_block_container");
            //create sequence view handles
            var dnl = create_seq_handle(blockCont, seqid, true);
            var dnr = create_seq_handle(blockCont, seqid, false);
            set_needles(offset, seqmax, dnl, start, dnr, start + width - 1);
          }
        }

        function create_info_section(cell, sequence, seqid, start, width, is_neg_strand) {
          var box = document.createElement('div');
          box.className = "box infobox";
          //generic info
          box.appendChild(document.createTextNode("Change the portion of annotated sequence by "));
          var bold_box = document.createElement('b');
          bold_box.appendChild(document.createTextNode("dragging the buttons"));
          box.appendChild(bold_box);
          box.appendChild(document.createTextNode("; hold shift to drag them individually."));
          box.appendChild(document.createElement('br'));
          box.appendChild(document.createElement('br'));
          //sequence display
          var seqDispTitle = document.createElement('h5');
          seqDispTitle.appendChild(document.createTextNode("Annotated Sequence"));
          box.appendChild(seqDispTitle);
          var show_rc_only = undefined;
          var annobox = document.createElement('div');
          annobox.id = seqid + "_annotation";
          set_data(start, width, show_rc_only, sequence, annobox);
          box.appendChild(annobox);
          cell.appendChild(box);
        }

        function annobox_labels() {
          var seqDispLabel = document.createElement('div');
          seqDispLabel.className = "sequence sequence_labels";
          seqDispLabel.style.height = "2.5em";
          return seqDispLabel;
        }

        function annobox_hits() {
          var seqDispHit = document.createElement('div');
          seqDispHit.className = "sequence";
          seqDispHit.style.height = "1.5em";
          return seqDispHit;
        }

        function annobox_matches() {
          var seqDispMatch = document.createElement('div');
          seqDispMatch.className = "sequence";
          seqDispMatch.style.height = "1.5em";
          return seqDispMatch;
        }

        function annobox_translations() {
          var seqDispXlate = document.createElement('div');
          seqDispXlate.className = "sequence";
          seqDispXlate.style.height = "1.5em";
          return seqDispXlate;
        }

        function annobox_sequence() {
          var seqDispSeq = document.createElement('div');
          seqDispSeq.className = "sequence";
          seqDispSeq.style.height = "1.5em";
          return seqDispSeq; 
        }
        function annobox_boundary() {
          var seqDispSeq = document.createElement('div');
          seqDispSeq.className = "sequence";
          seqDispSeq.style.height = "1.5em";
          return seqDispSeq; 
        }

        function create_seq_handle(container, seqid, isleft) {
          var vbar = document.createElement('div');
          vbar.id = seqid + "_dn" + (isleft ? "l" : "r");
          vbar.className = "block_needle" + (isleft ? "" : " right");
          var label = document.createElement('div');
          label.className = "block_handle" + (isleft ? "" : " right");
          label.appendChild(document.createTextNode("1"));
          label.style.cursor = 'pointer';
          label.title = "Drag to move the displayed range. Hold shift and drag to change " + (isleft ? "lower" : "upper") + " bound of the range.";
          vbar.appendChild(label);
          container.appendChild(vbar);
          label.onmousedown = function(evt) {
            evt = evt || window.event;
            start_drag(seqid, isleft, !(evt.shiftKey));
          };
          return vbar;
        }

        function destroy_seq_handle(seqid, isleft) {
          var vbar = document.getElementById(seqid + "_dn" + (isleft ? "l" : "r"));
          var label = vbar.firstChild;
          label.onmousedown = null;
          vbar.parentNode.removeChild(vbar);
        }

        function start_drag(seqid, mouse_on_left, move_both) {
          //first record what we are moving
          moving_left = mouse_on_left;
          moving_both = move_both;
          moving_seq = loadedSequences[seqid];
          if (!moving_seq) {
            alert("Sequence not loaded?!");
          }
          //get the container for movements to be judged against
          cont = document.getElementById(seqid + "_block_container");
          //get the div's that will be moved
          dnl = document.getElementById(seqid + "_dnl");
          dnr = document.getElementById(seqid + "_dnr");
          //get the div which has all the text containers that will be updated
          moving_annobox = document.getElementById(seqid + "_annotation");
          //calculate the space between handles
          moving_width = dnr.firstChild.firstChild.nodeValue - 
              dnl.firstChild.firstChild.nodeValue;
          drag_is_rc = undefined;
          //setup the events for draging
          document.onmousemove = handle_drag;
          document.onmouseup = finish_drag;
        }


        function calculate_width(obj) {
          return obj.clientWidth - (obj.style.paddingLeft ? obj.style.paddingLeft : 0) 
              - (obj.style.paddingRight ? obj.style.paddingRight : 0);
        }

        function calculate_drag_pos(ev) {
          var mouse = mouseCoords(ev);
          var dragable_length = calculate_width(cont);
          //I believe that the offset parent is the body
          //otherwise I would need to make this recursive
          //maybe clientLeft would work, but the explanation of
          //it is hard to understand and it apparently doesn't work
          //in firefox 2.
          var diff = mouse.x - cont.offsetLeft;
          if (diff < 0) diff = 0;
          if (diff > dragable_length) diff = dragable_length;
          var pos = Math.round(diff / dragable_length * (seqmax));
          return pos;
        }

        function handle_drag(ev) {
          var pos = calculate_drag_pos(ev);
          update_needles(pos, moving_seq.length, false);
        }

        function finish_drag(ev) {
          document.onmousemove = null;
          document.onmouseup = null;
          var pos = calculate_drag_pos(ev);
          update_needles(pos, moving_seq.length, true);
        }

        function update_needles(pos, seqlen, updateTxt) {
          var offset = moving_seq.segs[0].start;
          var leftPos = parseInt(dnl.firstChild.firstChild.nodeValue) - offset;
          var rightPos = parseInt(dnr.firstChild.firstChild.nodeValue) - offset;
          if (moving_both) {
            if (moving_left) {
              if ((pos + moving_width) >= seqlen) {
                pos = seqlen - moving_width - 1;
              }
              leftPos = pos;
              rightPos = pos + moving_width;
            } else {
              if (pos >= seqlen) {
                pos = seqlen - 1;
              } else if ((pos - moving_width) < 0) {
                pos = moving_width;
              }
              leftPos = pos - moving_width;
              rightPos = pos;
            }
          } else {
            if (moving_left) {
              if (pos > rightPos) {
                pos = rightPos;
              }
              leftPos = pos;
            } else {
              if (pos < leftPos) {
                pos = leftPos;
              } else if (pos >= seqlen) {
                pos = seqlen - 1;
              }
              rightPos = pos;
            }
          }
          set_needles(offset, seqmax, dnl, leftPos, dnr, rightPos);
          if (updateTxt) set_data(leftPos + offset, rightPos - leftPos + 1, drag_is_rc, moving_seq, moving_annobox);
        }

        function set_needles(offset, max, left, leftPos, right, rightPos) {
          //the needles are between the sequence positions
          //the left needle is before and the right needle after
          //think of it as an inclusive range...
          left.style.left = "" + (leftPos / max * 100)+ "%";
          left.firstChild.firstChild.nodeValue="" + (leftPos + offset);
          right.style.left = "" + ((rightPos+1) / max * 100)+ "%";
          right.firstChild.firstChild.nodeValue="" + (rightPos + offset);
        }

        function set_data(start, width, show_rc_only, data, annobox) {
          var child = annobox.firstChild;
          var line_width = Math.min(wrap, width);
          var num_per_wrap = 5
          var end = start + width;
          for (var i = start; i < end; i += line_width, line_width = Math.min(wrap, end - i)) {
            for (var j = 0; j < num_per_wrap; ++j) {
              if (child) {
                while (child.firstChild) child.removeChild(child.firstChild);
              } else {
                switch (j) {
                case 0:
                  child = annobox_labels();
                  break;
                case 1:
                  child = annobox_hits();
                  break;
                case 2:
                  child = annobox_matches();
                  break;
                case 3:
                  child = annobox_sequence();
                  break;
                case 4:
                  child = annobox_boundary();
                  break;
                }
                annobox.appendChild(child);
              }
              switch (j) {
              case 0:
                data.append_labels(child, i, line_width, show_rc_only);
                break;
              case 1:
                data.append_hits(child, i, line_width, show_rc_only);
                break;
              case 2:
                data.append_matches(child, i, line_width, show_rc_only);
                break;
              case 3:
                data.append_seq(child, i, line_width, show_rc_only);
                break;
              case 4:
                data.append_boundary(child, i, line_width, show_rc_only);
                break;
              }
              child = child.nextSibling;
            }
          }
          //clean up excess
          
          while (child) {
            var next = child.nextSibling;
            annobox.removeChild(child);
            child = next;
          }
        }

        function append_coloured_nucleotide_sequence(container, sequence) {
          var len = sequence.length;
          for (var i = 0; i < len; i++) {
            var colour = "black";
            switch (sequence.charAt(i)) {
            case 'A':
              colour = "red";
              break;
            case 'C':
              colour = "blue";
              break;
            case 'G':
              colour = "orange";
              break;
            case 'T':
              colour = "green";
              break;
            }
            var letter = document.createElement('span');
            letter.style.color = colour;
            letter.appendChild(document.createTextNode(sequence.charAt(i)));
            container.appendChild(letter);
          }
        }

        function append_coloured_peptide_sequence(container, sequence) {
          var len = sequence.length;
          for (var i = 0; i < len; i++) {
            var colour = "black";
            switch (sequence.charAt(i)) {
            case 'A':
            case 'C':
            case 'F':
            case 'I':
            case 'L':
            case 'V':
            case 'W':
            case 'M':
              colour = "blue";
              break;
            case 'N':
            case 'Q':
            case 'S':
            case 'T':
              colour = "green";
              break;
            case 'D':
            case 'E':
              colour = "magenta";
              break;
            case 'K':
            case 'R':
              colour = "red";
              break;
            case 'H':
              colour = "pink";
              break;
            case 'G':
              colour = "orange";
              break;
            case 'P':
              colour = "yellow";
              break;
            case 'Y':
              colour = "turquoise";
              break;
            }
            var letter = document.createElement('span');
            letter.style.color = colour;
            letter.appendChild(document.createTextNode(sequence.charAt(i)));
            container.appendChild(letter);
          }
        }

        /*
         * Finds the index of an item in a sorted array (a) that equals a key (k)
         * when compared using a comparator (c). If an exact match can not be found
         * then returns -(index+1), where index is the location that the item would be inserted.
         */
        function bsearch(a, c, k) {
          var low = 0;
          var high = a.length;
          while (low < high) {
            var mid = low + Math.floor((high - low) /2);
            if (c(a[mid], k) < 0) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          if ((low < a.length) && (c(a[low], k) == 0)) {
            return low;
          } else {
            return -(low+1);
          }
        }

        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // Start Motif Object
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        function Motif(name, type, best_f, best_rc) {
          this.name = name;
          this.is_nucleotide = (type === "nucleotide");
          this.best_f = best_f;
          this.best_rc = best_rc;
          this.length = best_f.length;
        }
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // End Motif Object
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // Start Seg Object
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        function Seg(start, segment) {
          this.start = parseInt(start);
          this.segment = segment;
        }

        function compare_seg_to_pos(seg, pos) {
          return seg.start - pos;
        }
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // End Seg Object
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // Start Hit Object
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        function Hit(sequence_is_nucleotide, motif, pos, strand, pvalue, match) {
          //properties
          this.motif = motif;
          this.pos = parseInt(pos);
          this.width = 0;
          this.is_rc = (strand != "+");
          this.pvalue = pvalue;
          this.best = "";
          this.match = "";
          //functions
          this.find_overlap = Hit_find_overlap;
          //setup
          var seq;
          var m = match.replace(/ /g, "");
          if (this.is_rc) {
            seq = this.motif.best_rc;
          }
          else {
            seq = this.motif.best_f;
          }
          if (sequence_is_nucleotide == this.motif.is_nucleotide) {
            this.best = seq;
            this.match = m;
            this.width = motif.length;
          } else if (sequence_is_nucleotide) {
            this.width = motif.length * 3;
            for (var i = 0; i < motif.length; i++) {
              this.best += seq.charAt(i);
              this.best += "..";
              this.match += m.charAt(i);
              this.match += "";
            }
          } else {
            throw "UNSUPPORTED_CONVERSION";
          }
        }

        function Hit_find_overlap(sequence_is_nucleotide, start, width) {
          if (this.pos < start) {
            if ((this.pos + this.width) > start) {
              return {hit: this, start: start, length: Math.min(width, (this.pos + this.width - start))};
            } else {
              return null;
            }
          } else if (this.pos < (start + width)) {
            return {hit: this, start: this.pos, length: Math.min(this.width, (start + width - this.pos))};
          }
          return null;
        }

        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // End Hit Object
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // Start Overlapping Hit Iterator
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        function OLHIterator(sequence, start, width, is_rc) {
          //properties
          this.sequence = sequence;
          this.start = start;
          this.width = width;
          this.is_rc = is_rc;
          this.both = (is_rc === undefined);
          this.index = 0;
          this.nextO = null;
          //methods
          this.next = OLHIterator_next;
          this.has_next = OLHIterator_has_next;
          //setup
          // find the first hit which overlaps the range
          for (; this.index < this.sequence.hits.length; this.index++) {
            var hit = this.sequence.hits[this.index];
            if (!this.both && this.is_rc != hit.is_rc) continue;
            if ((this.nextO = hit.find_overlap(this.sequence.is_nucleotide, this.start, this.width)) != null) break;
          }
        }
        
        function OLHIterator_next() {
          if (this.nextO == null) throw "NO_NEXT_ELEMENT";
          var current = this.nextO;
          this.nextO = null;
          for (this.index = this.index + 1; this.index < this.sequence.hits.length; this.index++) {
            var hit = this.sequence.hits[this.index];
            if (!this.both && this.is_rc != hit.is_rc) continue;
            this.nextO = hit.find_overlap(this.sequence.is_nucleotide, this.start, this.width);
            break;
          }
          return current;
        }
        
        function OLHIterator_has_next() {
          return (this.nextO != null);
        }

        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // End Overlapping Hit Iterator
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // Start Sequence Object
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        function Sequence(seqid) {
          //properties
          this.length = parseInt(document.getElementById(seqid + "_len").value);
          this.cpvalue = document.getElementById(seqid + "_combined_pvalue").value;
          this.is_nucleotide = (document.getElementById(seqid + "_type").value === "nucleotide");
          this.segs = new Array(); //sorted list of segs
          this.hits = new Array(); //sorted list of hits
          //functions
          this.get_overlapping_hits = Sequence_get_overlapping_hits;
          this.append_seq = Sequence_append_seq;
          this.append_translation = Sequence_append_translation;
          this.append_hits = Sequence_append_hits;
          this.append_matches = Sequence_append_matches;
          this.append_labels = Sequence_append_labels;
          this.append_boundary = Sequence_append_boundary;
          //init
          //made this parser much more permissive as a new
          //version of libxml2 broke the translate call I was
          //using to remove whitespace characters
          var mysegs = document.getElementById(seqid + "_segs");
          var tokens = mysegs.value.split(/\s+/);
          var offsetnum = "";
          var seqchunk = "";
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (token == "") continue;
            if (token.match(/\d+/)) {
              if (offsetnum != "" && seqchunk != "") {
                this.segs.push(new Seg(offsetnum, seqchunk));
              }
              offsetnum = parseInt(token, 10);
              seqchunk = "";
              continue;
            }
            seqchunk += token;
          }
          if (offsetnum != "" && seqchunk != "") {
            this.segs.push(new Seg(offsetnum, seqchunk));
          }
          var myhits = document.getElementById(seqid + "_hits");
          lines = myhits.value.split(/\n/);
          for (var i in lines) {
            //exclude inherited properties and undefined properties
            if (!lines.hasOwnProperty(i) || lines[i] === undefined) continue;
            
            var line = lines[i];
            var chunks = line.split(/\t/);
            if (chunks.length != 5) continue;
            var pos = chunks[0];
            var motif = motifs[chunks[1]];
            var strand = chunks[2];
            var pvalue = chunks[3];
            var match = chunks[4];
            this.hits.push(new Hit(this.is_nucleotide, motif, pos, strand, pvalue, match));
          }
        }

        function Sequence_get_overlapping_hits(start, width, is_rc) {
          return new OLHIterator(this, start, width, is_rc);
        }

        function Sequence_append_seq(container, start, width, is_rc) {
          //make a sub container to put the sequence in
          var mycontainer = document.createElement('span');
          // find where a seg starting at start would be
          var i = bsearch(this.segs, compare_seg_to_pos, start);
          var seg;
          var sequence = "";
          if (i < -1) {
            //possible partial segment, need to handle first
            i = -(i + 1);
            seg = this.segs[i-1];
            if ((seg.start + seg.segment.length) > start) {
              var seg_offset = start - seg.start;
              var seg_width = Math.min(width, seg.segment.length - seg_offset);
              sequence += seg.segment.substring(seg_offset, seg_offset + seg_width);
            }
          } else if (i == -1) {
            //gap, with following segment, normal state at start of iteration
            i = 0;
          } 
          for (;i < this.segs.length; i++) {
            seg = this.segs[i];
            var gap_width = Math.min(width - sequence.length, seg.start - (start + sequence.length));
            for (; gap_width > 0; gap_width--) sequence += '-';
            var seg_width = Math.min(width - sequence.length, seg.segment.length);
            if (seg_width == 0) break;
            sequence += seg.segment.substring(0, seg_width);
          }
          while (sequence.length < width) sequence += '-';
          // calculate which parts are aligned with hits and output them in colour
          var pos = start;
          var iter = this.get_overlapping_hits(start, width, is_rc);
          while (iter.has_next()) {
            var o = iter.next();
            var from, to;
            if (o.start > pos) {
              from = pos - start;
              to = o.start - start;
              var subseq = sequence.substring(from, to);
              var greytxt = document.createElement('span');
              greytxt.style.color = 'grey';
              greytxt.appendChild(document.createTextNode(subseq));
              mycontainer.appendChild(greytxt);
              pos = o.start;
            }
            from = pos - start;
            to = from + o.length;
            var motifseq = sequence.substring(from, to);
            if (this.is_nucleotide) {
              append_coloured_nucleotide_sequence(mycontainer, motifseq);
            } else {
              append_coloured_peptide_sequence(mycontainer, motifseq);
            }
            pos += o.length;
          }
          if (pos < (start + width)) {
            var greytxt = document.createElement('span');
            greytxt.style.color = 'grey';
            greytxt.appendChild(document.createTextNode(sequence.substring(pos - start)));
            mycontainer.appendChild(greytxt);
          }
          container.appendChild(mycontainer);
        }

        function Sequence_append_translation(container, start, width, is_rc) {
          if (start > this.length) {
            alert("start: " + start + " length: " + this.length);
            throw "INDEX_OUT_OF_BOUNDS";
          }
          if ((start + width - 1) > this.length) {
            alert("start: " + start + " width: " + width + " length: " + this.length);
            throw "RANGE_OUT_OF_BOUNDS";
          }
          //make a sub container to put the sequence in
          var mycontainer = document.createElement('span');
          // calculate which parts are aligned with hits and output them in colour
          var pos = start;
          var iter = this.get_overlapping_hits(start, width, is_rc);
          while (iter.has_next()) {
            var o = iter.next();
            var space = "";
            var from, to;
            while (o.start > pos) {
              space += "";
              ++pos;
            }
            if (space.length > 0) {
              var spacer = document.createElement('span');
              spacer.appendChild(document.createTextNode(space));
              mycontainer.appendChild(spacer);
            }
            from = o.start - o.hit.pos;
            to = from + o.length;
            if (o.hit.motif.is_nucleotide) {
              append_coloured_nucleotide_sequence(mycontainer, motifseq);
            } else {
              append_coloured_peptide_sequence(mycontainer, motifseq);
            }
            pos += o.length;
          }

          container.appendChild(mycontainer);
        }

        function Sequence_append_matches(container, start, width, is_rc) {
          //make a sub container to put the sequence in
          var mycontainer = document.createElement('span');
          var pos = start;
          var text = "";
          var iter = this.get_overlapping_hits(start, width, is_rc);
          while (iter.has_next()) {
            var o = iter.next();
            var space = "";
            var from, to;
            while (o.start > pos) {
              text += "";
              ++pos;
            }
            from = o.start - o.hit.pos;
            to = from + o.length;
            var motifseq = o.hit.match.substring(from, to);
            text += motifseq
            pos += o.length;
          }
          mycontainer.appendChild(document.createTextNode(text));
          container.appendChild(mycontainer);
        }

        function Sequence_append_hits(container, start, width, is_rc) {
          //make a sub container to put the sequence in
          var mycontainer = document.createElement('span');
          // calculate which parts are aligned with hits and output them in colour
          var pos = start;
          var iter = this.get_overlapping_hits(start, width, is_rc);
          while (iter.has_next()) {
            var o = iter.next();
            var space = "";
            var from, to;
            while (o.start > pos) {
              space += "";
              ++pos;
            }
            if (space.length > 0) {
              var spacer = document.createElement('span');
              spacer.appendChild(document.createTextNode(space));
              mycontainer.appendChild(spacer);
            }
            from = o.start - o.hit.pos;
            to = from + o.length;
            var motifseq = o.hit.best.substring(from, to);
            if (o.hit.motif.is_nucleotide) {
              append_coloured_nucleotide_sequence(mycontainer, motifseq);
            } else {
              append_coloured_peptide_sequence(mycontainer, motifseq);
            }
            pos += o.length;
          }

          container.appendChild(mycontainer);
        }

        function Sequence_append_labels(container, start, width, is_rc) {
          //create a table (ye gods...)
          var oTable = document.createElement("table");
          var oRow = oTable.insertRow(oTable.rows.length);

          // calculate where to put the labels
          var pos = start;
          var cellindex = 0;
          var iter = this.get_overlapping_hits(start, width, is_rc);
          while (iter.has_next()) {
            var o = iter.next();
            var motif_center = Math.floor(o.start + o.length / 2);
            var spacer = "";
            while (pos < motif_center) {
              spacer += "";
              pos++;
            }
            var cell1 = oRow.insertCell(cellindex++);
            cell1.appendChild(document.createTextNode(spacer));
            //add one for the div
            pos++;
            var cell2 = oRow.insertCell(cellindex++);
            //create the div that holds the label divs
            var div_container = document.createElement('div');
            div_container.className = "label_container";
            cell2.appendChild(div_container);
            //create the top label
            var top_label = "";
            
              top_label += "(";
              if (o.hit.is_rc) {
                top_label += "-";
              } else {
                top_label += "+";
              }
              top_label += ") ";
            
            if (o.hit.motif.name.match(/^\d+$/)) {
              top_label += "Motif " + o.hit.motif.name;
            } else {
              top_label += o.hit.motif.name;
            }
            var div_top_label = document.createElement('div');
            div_top_label.className = "sequence_label sequence_label_top";
            div_top_label.style.width = "" + top_label.length + "em";
            div_top_label.style.left = "-" + (top_label.length / 2) + "em";
            div_top_label.appendChild(document.createTextNode(top_label));
            //create the bottom label
            var bottom_label = o.hit.pvalue;
            var div_bottom_label = document.createElement('div');
            div_bottom_label.className = "sequence_label sequence_label_bottom";
            div_bottom_label.style.width = "" + bottom_label.length + "em";
            div_bottom_label.style.left = "-" + (bottom_label.length / 2) + "em";
            div_bottom_label.appendChild(document.createTextNode(bottom_label));
            //add the label divs to the positioned container
            div_container.appendChild(div_top_label);
            div_container.appendChild(div_bottom_label);
          }
          container.appendChild(oTable);

        }

        function Sequence_append_boundary(container, start, width, is_rc) {
          //make a sub container to put the sequence in
          var mycontainer = document.createElement('span');
          var pos = start;
          var text = "";
          var iter = this.get_overlapping_hits(start, width, is_rc);
          while (iter.has_next()) {
            var o = iter.next();
            var end;
            while (o.start > pos) {
              text += "";
              ++pos;
            }
            if (o.start == o.hit.pos) {
              text += "\\";
              ++pos;
            }
            end = o.start + o.length - 1;
            while (end > pos) {
              text += "_";
              ++pos;
            }
            if (end == (o.hit.pos + o.hit.width -1)) {
              text += "/"
            } else {
              text += "_"
            }
            ++pos;
          }
          mycontainer.appendChild(document.createTextNode(text));
          container.appendChild(mycontainer);
        }
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        // End Sequence Object
        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      </script><style type="text/css">
    
    /* START INCLUDED FILE "meme.css" */
        /* The following is the content of meme.css */
        body { background-color:white; font-size: 12px; font-family: Verdana, Arial, Helvetica, sans-serif;}

        div.help {
          display: inline-block;
          margin: 0px;
          padding: 0px;
          width: 12px;
          height: 13px;
          cursor: pointer;
          background-image: url("help.gif");
          background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAANAQMAAACn5x0BAAAAAXNSR0IArs4c6QAAAAZQTFRFAAAAnp6eqp814gAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH2gMJBQgGYqhNZQAAACZJREFUCNdj+P+BoUGAoV+AYeYEEGoWYGgTYGgRAAm2gRGQ8f8DAOnhC2lYnqs6AAAAAElFTkSuQmCC");
        }

        div.help2 {
          color: #999;
          display: inline-block;
          width: 12px;
          height: 12px;
          border: 1px solid #999;
          font-size: 13px;
          line-height:12px;
          font-family: Helvetica, sans-serif;
          font-weight: bold;
          font-style: normal;
          cursor: pointer;
        }
        div.help2:hover {
          color: #000;
          border-color: #000;
        }
        
        p.spaced { line-height: 1.8em;}
        
        span.citation { font-family: "Book Antiqua", "Palatino Linotype", serif; color: #004a4d;}

        p.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}

        td.jump { font-size: 13px; color: #ffffff; background-color: #00666a;
          font-family: Georgia, "Times New Roman", Times, serif;}

        a.jump { margin: 15px 0 0; font-style: normal; font-variant: small-caps;
          font-weight: bolder; font-family: Georgia, "Times New Roman", Times, serif;}

        h2.mainh {font-size: 1.5em; font-style: normal; margin: 15px 0 0;
          font-variant: small-caps; font-family: Georgia, "Times New Roman", Times, serif;}

        h2.line {border-bottom: 1px solid #CCCCCC; font-size: 1.5em; font-style: normal;
          margin: 15px 0 0; padding-bottom: 3px; font-variant: small-caps;
          font-family: Georgia, "Times New Roman", Times, serif;}

        h4 {border-bottom: 1px solid #CCCCCC; font-size: 1.2em; font-style: normal;
          margin: 10px 0 0; padding-bottom: 3px; font-family: Georgia, "Times New Roman", Times, serif;}

        h5 {margin: 0px}

        a.help { font-size: 9px; font-style: normal; text-transform: uppercase;
          font-family: Georgia, "Times New Roman", Times, serif;}

        div.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}
        
        div.pad1 { margin: 10px 5px;}

        div.pad2 { margin: 25px 5px 5px;}
        h2.pad2 { padding: 25px 5px 5px;}

        div.pad3 { padding: 5px 0px 10px 30px;}

        div.box { border: 2px solid #CCCCCC; padding:10px;}

        div.bar { border-left: 7px solid #00666a; padding:5px; margin-top:25px; }

        div.subsection {margin:25px 0px;}

        img {border:0px none;}

        th.majorth {text-align:left;}
        th.minorth {font-weight:normal; text-align:left; width:8em; padding: 3px 0px;}
        th.actionth {font-weight:normal; text-align:left;}

        .strand_name {text-align:left;}
        .strand_side {padding:0px 10px;}
        .strand_start {padding:0px 10px;}
        .strand_pvalue {text-align:center; padding:0px 10px;}
        .strand_lflank {text-align:right; padding-right:5px; font-weight:bold; font-size:large; font-family: 'Courier New', Courier, monospace; color:gray;}
        .strand_seq {text-align:center; font-weight:bold; font-size:large; font-family: 'Courier New', Courier, monospace;}
        .strand_rflank {text-align:left; padding-left:5px; font-weight:bold; font-size:large; font-family: 'Courier New', Courier, monospace; color:gray;}

        .block_td {height:25px;}
        .block_container {position:relative; width:98%; height:25px; padding:0px; margin: 0px 0px 0px 1em;}
        .block_motif {position:absolute; z-index:3; height:12px; top:0px; text-align:center; vertical-align:middle; background-color:cyan;}
        .block_rule {position:absolute; z-index:2; width:100%; height:1px; top:12px; left:0px; background-color:gray;}
        .block_plus_sym {position:absolute; z-index:4; line-height:12px; top:0px; left:-1em;}
        .block_minus_sym {position:absolute; z-index:4; line-height:12px; top:13px; left:-1em;}

        .tic_major {position:absolute; border-left:2px solid blue; height:0.5em; top:0em;}
        .tic_minor {position:absolute; border-left:1px solid blue; height:0.2em; top:0em;}
        .tic_label {position:absolute; top:0.5em;  height: 1em; text-align:center; vertical-align:middle}

        .explain h5 {font-size:1em; margin-left: 1em;}

        div.doc {margin-left: 2em; margin-bottom: 3em;}
        
        div.tabArea {
          font-size: 80%;
          font-weight: bold;
        }

        a.tab {
          background-color: #ddddff;
          border: 1px solid #000000;
          padding: 2px 1em 2px 1em;
          text-decoration: none;
        }
        div.tabArea.base a.tab {
          border-top-width: 0px;
        }
        div.tabArea.top a.tab {
          border-bottom-width: 0px;
        }

        a.tab, a.tab:visited {
          color: #808080;
        }

        a.tab:hover {
          background-color: #d0d0d0;
          color: #606060;
        }
        a.tab.activeTab, a.tab.activeTab:hover, a.tab.activeTab:visited {
          background-color: #f0f0f0;
          color: #000000;
        }
        div.tabMain {
          border: 1px solid #000000;
          background-color: #ffffff;
          padding: 5px;
          margin-right: 5px;
        }
        th.trainingset {
          border-bottom: thin dashed black; 
          font-weight:normal; 
          padding:0px 10px;
        }
        .dnaseq {
          font-weight: bold; 
          font-size: large; 
          font-family: 'Courier New', Courier, monospace;
        }
        .dna_A {
          color: rgb(204,0,0);
        }
        .dna_C {
          color: rgb(0,0,204);
        }
        .dna_G {
          color: rgb(255,179,0);
        }
        .dna_T {
          color: rgb(0,128,0);
        }
    /* END INCLUDED FILE "meme.css" */
    
  
        .more_arrow {
          font-family:Arial,Serif;
          font-size: larger;
          font-weight: bold;
          text-decoration:none; 
        }
        div.infobox {
          background-color:#ddddff;
          margin-top: 50px;
          margin-bottom: 1em;
        }
        .sequence {font-family:Monospace;}
        .sequence_labels {position:relative; width:100%; height:2.5em; 
            padding:0px; margin:0px;}
        .sequence_label {font-family:Serif; position:absolute; z-index:2; 
            height:1em; text-align:center; vertical-align:middle;}
        .sequence_label_top {top:0px;}
        .sequence_label_bottom {top:1.25em;}
        .inlineTitle {display:inline;}
        .block_needle {position:absolute; z-index:4; height:30px; width:1px; 
            top:-2px; background-color:gray;}
        .block_handle {position:absolute; z-index:5; height:1.1em; width:7em; 
            top:30px; left:-4em; text-align:center; vertical-align:middle;
            background-color: LightGrey; border:3px outset grey; 
            -moz-user-select: none; -khtml-user-select: none; user-select: none;}
        .block_needle.right {height: 50px;}
        .block_handle.right {top:50px;}
        .label_container {position:relative; width:100%; height:25px; padding:0px; margin: 0px;}

        table.padded-table td { padding:0px 10px; }
        table.padded-table th { padding:0px 5px; }
        td.tnum {text-align:right;}
        tr.highlight {background:#aaffaa;}
        td.dim {color: gray;}
        span.dim {color: gray;}
        .col_seq { text-align: left; width: 6.4em}
        .col_start, .col_stop, .col_score, .col_pv, .col_ev, .col_qv { text-align:right; }
        .col_start {width: 8em}
        .col_stop {width: 8em}
        .col_score {width: 5em}
        .col_pv {width: 5em}
        .col_ev {width: 5em}
        .col_qv {width: 5em}
        .col_more {width: 1em}
        .col_extra {width: *}
        .col_bd {width: 100%}
      </style></head><body onload="javascript:setup()"><a name="inputs"></a><table width="100%" border="0" cellspacing="1" cellpadding="4" bgcolor="#FFFFFF"><tr><td><h2 class="mainh">Inputs</h2></td><td align="right" valign="bottom"></td></tr></table><div class="box"><a name="databases"></a><h4>Sequence Database</h4><div class="pad"><p>The sequence
          "test.fa"
          was supplied.</p><table class="padded-table" border="0"><col><col><thead><tr><th>Sequence Count</th><th>Residue Count</th></tr></thead><tbody><tr><td class="tnum">2</td><td class="tnum">90</td></tr></tbody><tfoot></tfoot></table></div><a name="motifs"></a><h4>Motifs</h4><div class="pad"><p>The following motifs were supplied
        </p><table class="padded-table" border="0"><thead><tr><th></th><th></th><th></th></tr><tr><th>Motif</th><th>Width</th></tr></thead><tbody><tr><td>CCGGT</td><td>5</td></tr><tr><td>TTAA</td><td>4</td></tr></tbody></table></div></div><a name="results"></a><table width="100%" border="0" cellspacing="1" cellpadding="4" bgcolor="#FFFFFF"><tr><td><h2 class="mainh">Search Results</h2></td><td align="right" valign="bottom"></td></tr></table><div class="box"><h4>Top Scoring Matches</h4><div class="pad"><p><b>Click on the arrow</b> () next to the block diagram to view more information about a sequence.
        </p><div style="text-align:left"><table style="display:inline-block; padding:5px;"><tr><td><div style="width: 20px; height: 20px; background-color:aqua; border: 1px solid black"></div></td><td>Motif CCGGT</td></tr></table><table style="display:inline-block; padding:5px;"><tr><td><div style="width: 20px; height: 20px; background-color:blue; border: 1px solid black"></div></td><td>Motif TTAA</td></tr></table></div><table id="tbl_sequences" style="width:100%; table-layout:fixed;" border="0"><thead><tr><th class="col_seq">Sequence</th><th class="col_start">Start</th><th class="col_stop">Stop</th></tr></thead><tbody><tr><td class="col_seq">seq1</td><td class="col_start">1</td><td class="col_stop">43</td><td class="col_pv">--</td><td class="col_ev">--</td><td class="col_qv">--</td><td class="col_extra"></td><td class="col_more"></td></tr><tr class="col_bd" id="cluster-1_blocks"><td class="block_td" colspan="8"><div class="block_container" id="cluster-1_block_container"><div class="block_plus_sym">+</div><div class="block_minus_sym">-</div><div class="block_rule" style="width:91.4893617021277%"></div><div class="block_motif" style="left:8.510999999999999%; top:-1px; width:10.638%; height:12px; background-color:aqua; border: 1px solid black;" title="Motif CCGGT    p-value: 0    starts: 5    ends: 9    "></div><div class="block_motif" style="left:29.787%; top:-1px; width:10.638%; height:12px; background-color:aqua; border: 1px solid black;" title="Motif CCGGT    p-value: 0    starts: 15    ends: 19    "></div><div class="block_motif" style="left:80.851%; top:-1px; width:10.638%; height:12px; background-color:aqua; border: 1px solid black;" title="Motif CCGGT    p-value: 0    starts: 39    ends: 43    "></div><div class="block_motif" style="left:44.681%; top:-1px; width:8.510999999999999%; height:12px; background-color:blue; border: 1px solid black;" title="Motif TTAA    p-value: 0    starts: 22    ends: 25    "></div></div></td><td class="col_more"><a href="javascript:show_more('cluster-1')" class="more_arrow" title="Toggle additional information"></a></td></tr><tr><td class="col_seq">seq2</td><td class="col_start">1</td><td class="col_stop">47</td><td class="col_pv">--</td><td class="col_ev">--</td><td class="col_qv">--</td><td class="col_extra"></td><td class="col_more"></td></tr><tr class="col_bd" id="cluster-2_blocks"><td class="block_td" colspan="8"><div class="block_container" id="cluster-2_block_container"><div class="block_plus_sym">+</div><div class="block_minus_sym">-</div><div class="block_rule" style="width:100%"></div><div class="block_motif" style="left:12.766%; top:-1px; width:8.510999999999999%; height:12px; background-color:blue; border: 1px solid black;" title="Motif TTAA    p-value: 0    starts: 7    ends: 10    "></div><div class="block_motif" style="left:91.489%; top:-1px; width:8.510999999999999%; height:12px; background-color:blue; border: 1px solid black;" title="Motif TTAA    p-value: 0    starts: 44    ends: 47    "></div></div></td><td class="col_more"><a href="javascript:show_more('cluster-2')" class="more_arrow" title="Toggle additional information"></a></td></tr></tbody></table></div></div><!--This data is used by the javascript to create the detailed views--><form><input type="hidden" id="cluster-1_len" value="43"><input type="hidden" id="cluster-1_combined_pvalue" value=""><input type="hidden" id="cluster-1_type" value="nucleotide"><input type="hidden" id="cluster-1_segs" value="1AAACCCGGTGGAAACCGGTTTTTAAGGATATAGACCCCCCGGA
"><input type="hidden" id="cluster-1_hits" value="5CCGGT0CCGGT15CCGGT0CCGGT39CCGGT0CCGGT22TTAA0TTAA"><input type="hidden" id="cluster-2_len" value="47"><input type="hidden" id="cluster-2_combined_pvalue" value=""><input type="hidden" id="cluster-2_type" value="nucleotide"><input type="hidden" id="cluster-2_segs" value="1CCCGGGTTAAGATTGACAGATGATGACACGAGGGAGAGAGGATTTAT
"><input type="hidden" id="cluster-2_hits" value="7TTAA0TTAA44TTAA0TTAA"></form><p>
	This visualization was taken from "The MEME Suite Motif-based sequence analysis tools". <a href="http://meme.sdsc.edu/meme/intro.html"> MEME </a>.
	<br><br>
	Timothy L. Bailey, Mikael Boden, Fabian A. Buske, Martin Frith, Charles E. Grant, Luca Clementi, Jingyuan Ren, Wilfred W. Li, William S. Noble, 
	<br>
	"MEME SUITE: tools for motif discovery and searching", Nucleic Acids Research, 37:W202-W208, 2009
	<br></p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><span class="sequence" id="ruler" style="visibility:hidden; white-space:nowrap;">ACGTN</span></body></html>
